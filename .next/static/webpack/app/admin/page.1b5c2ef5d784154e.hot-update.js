"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/page",{

/***/ "(app-pages-browser)/./src/services/api.ts":
/*!*****************************!*\
  !*** ./src/services/api.ts ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   brandAPI: () => (/* binding */ brandAPI),\n/* harmony export */   carAPI: () => (/* binding */ carAPI),\n/* harmony export */   categoryAPI: () => (/* binding */ categoryAPI),\n/* harmony export */   searchAPI: () => (/* binding */ searchAPI)\n/* harmony export */ });\n/* harmony import */ var _lib_firebase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/firebase */ \"(app-pages-browser)/./src/lib/firebase.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n// Use external backend server (Render) instead of local API routes\nconst API_BASE_URL = process.env.NEXT_PUBLIC_BACKEND_URL || '';\nconsole.log('API_BASE_URL:', API_BASE_URL);\nconsole.log('NEXT_PUBLIC_BACKEND_URL:', process.env.NEXT_PUBLIC_BACKEND_URL);\n// Car API endpoints\nconst carAPI = {\n    getAllCars: async ()=>{\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/cars\"), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Cache-Control': 'no-cache',\n                    'cache-control': 'no-cache'\n                }\n            });\n            if (!response.ok) {\n                const error = await response.text();\n                throw new Error(error || 'Failed to fetch cars');\n            }\n            return response.json();\n        } catch (error) {\n            console.error('Error fetching cars:', error);\n            return []; // Return empty array instead of throwing\n        }\n    },\n    getCarsByType: async (type)=>{\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/cars/type/\").concat(encodeURIComponent(type)), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Cache-Control': 'no-cache',\n                    'cache-control': 'no-cache'\n                }\n            });\n            if (!response.ok) {\n                const error = await response.text();\n                throw new Error(error || 'Failed to fetch cars by type');\n            }\n            return response.json();\n        } catch (error) {\n            console.error('Error fetching cars by type:', error);\n            return []; // Return empty array instead of throwing\n        }\n    },\n    getCarsByTag: async (tag)=>{\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/cars/tag/\").concat(encodeURIComponent(tag)), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Cache-Control': 'no-cache',\n                    'cache-control': 'no-cache'\n                }\n            });\n            if (!response.ok) {\n                const error = await response.text();\n                throw new Error(error || 'Failed to fetch cars by tag');\n            }\n            return response.json();\n        } catch (error) {\n            console.error('Error fetching cars by tag:', error);\n            return []; // Return empty array instead of throwing\n        }\n    },\n    getCarsByFuelType: async (fuelType)=>{\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/cars/fuel-type/\").concat(encodeURIComponent(fuelType)), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Cache-Control': 'no-cache',\n                    'cache-control': 'no-cache'\n                }\n            });\n            if (!response.ok) {\n                const error = await response.text();\n                throw new Error(error || 'Failed to fetch cars by fuel type');\n            }\n            return response.json();\n        } catch (error) {\n            console.error('Error fetching cars by fuel type:', error);\n            return []; // Return empty array instead of throwing\n        }\n    },\n    getCarsByBrand: async (brand)=>{\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/cars/brand/\").concat(encodeURIComponent(brand)), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Cache-Control': 'no-cache',\n                    'cache-control': 'no-cache'\n                }\n            });\n            if (!response.ok) {\n                const error = await response.text();\n                throw new Error(error || 'Failed to fetch cars by brand');\n            }\n            return response.json();\n        } catch (error) {\n            console.error('Error fetching cars by brand:', error);\n            return []; // Return empty array instead of throwing\n        }\n    },\n    getFeaturedCars: async ()=>{\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/cars/featured\"), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Cache-Control': 'no-cache',\n                    'cache-control': 'no-cache'\n                }\n            });\n            if (!response.ok) {\n                const error = await response.text();\n                throw new Error(error || 'Failed to fetch featured cars');\n            }\n            return response.json();\n        } catch (error) {\n            console.error('Error fetching featured cars:', error);\n            return []; // Return empty array instead of throwing\n        }\n    },\n    getCarById: async (id)=>{\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/cars/\").concat(encodeURIComponent(id)), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Cache-Control': 'no-cache',\n                    'cache-control': 'no-cache'\n                }\n            });\n            if (!response.ok) {\n                const error = await response.text();\n                throw new Error(error || 'Failed to fetch car');\n            }\n            return response.json();\n        } catch (error) {\n            console.error('Error fetching car:', error);\n            throw error; // Re-throw the error\n        }\n    },\n    createCar: async (car)=>{\n        try {\n            if (!_lib_firebase__WEBPACK_IMPORTED_MODULE_0__.auth.currentUser) {\n                throw new Error('Not authenticated');\n            }\n            const token = await _lib_firebase__WEBPACK_IMPORTED_MODULE_0__.auth.currentUser.getIdToken();\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/cars\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': \"Bearer \".concat(token)\n                },\n                body: JSON.stringify(car)\n            });\n            if (!response.ok) {\n                const error = await response.text();\n                throw new Error(error || 'Failed to create car');\n            }\n            return response.json();\n        } catch (error) {\n            console.error('Error creating car:', error);\n            throw error;\n        }\n    },\n    updateCar: async (id, car)=>{\n        try {\n            if (!_lib_firebase__WEBPACK_IMPORTED_MODULE_0__.auth.currentUser) {\n                throw new Error('Not authenticated');\n            }\n            const token = await _lib_firebase__WEBPACK_IMPORTED_MODULE_0__.auth.currentUser.getIdToken();\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/cars/\").concat(encodeURIComponent(id)), {\n                method: 'PUT',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': \"Bearer \".concat(token)\n                },\n                body: JSON.stringify(car)\n            });\n            if (!response.ok) {\n                const error = await response.text();\n                throw new Error(error || 'Failed to update car');\n            }\n            const updatedCar = await response.json();\n            return updatedCar;\n        } catch (error) {\n            console.error('Error updating car:', error);\n            throw error;\n        }\n    },\n    deleteCar: async (id)=>{\n        try {\n            if (!_lib_firebase__WEBPACK_IMPORTED_MODULE_0__.auth.currentUser) {\n                throw new Error('Not authenticated');\n            }\n            const token = await _lib_firebase__WEBPACK_IMPORTED_MODULE_0__.auth.currentUser.getIdToken();\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/cars/\").concat(encodeURIComponent(id)), {\n                method: 'DELETE',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': \"Bearer \".concat(token)\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>null);\n                throw new Error((errorData === null || errorData === void 0 ? void 0 : errorData.error) || 'Failed to delete car');\n            }\n        } catch (error) {\n            console.error('Error deleting car:', error);\n            throw error;\n        }\n    }\n};\n// Category API endpoints\nconst categoryAPI = {\n    getCategoriesByType: async (type)=>{\n        try {\n            var _auth_currentUser;\n            const token = await ((_auth_currentUser = _lib_firebase__WEBPACK_IMPORTED_MODULE_0__.auth.currentUser) === null || _auth_currentUser === void 0 ? void 0 : _auth_currentUser.getIdToken());\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/categories/type/\").concat(encodeURIComponent(type)), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': token ? \"Bearer \".concat(token) : '',\n                    'Cache-Control': 'no-cache',\n                    'cache-control': 'no-cache'\n                }\n            });\n            if (!response.ok) {\n                const error = await response.text();\n                throw new Error(error || 'Failed to fetch categories by type');\n            }\n            return response.json();\n        } catch (error) {\n            console.error('Error fetching categories by type:', error);\n            return [];\n        }\n    },\n    getCategoryBySlug: async (slug)=>{\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/categories/slug/\").concat(encodeURIComponent(slug)), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Cache-Control': 'no-cache',\n                    'cache-control': 'no-cache'\n                }\n            });\n            if (!response.ok) {\n                if (response.status === 404) {\n                    return null;\n                }\n                const error = await response.text();\n                throw new Error(error || 'Failed to fetch category by slug');\n            }\n            return response.json();\n        } catch (error) {\n            console.error('Error fetching category by slug:', error);\n            return null;\n        }\n    },\n    getFeaturedCategories: async ()=>{\n        try {\n            var _auth_currentUser;\n            const token = await ((_auth_currentUser = _lib_firebase__WEBPACK_IMPORTED_MODULE_0__.auth.currentUser) === null || _auth_currentUser === void 0 ? void 0 : _auth_currentUser.getIdToken());\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/categories/featured\"), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': token ? \"Bearer \".concat(token) : '',\n                    'Cache-Control': 'no-cache',\n                    'cache-control': 'no-cache'\n                }\n            });\n            if (!response.ok) {\n                const error = await response.text();\n                throw new Error(error || 'Failed to fetch featured categories');\n            }\n            return response.json();\n        } catch (error) {\n            console.error('Error fetching featured categories:', error);\n            return [];\n        }\n    },\n    createCategory: async (category)=>{\n        try {\n            var _auth_currentUser;\n            const token = await ((_auth_currentUser = _lib_firebase__WEBPACK_IMPORTED_MODULE_0__.auth.currentUser) === null || _auth_currentUser === void 0 ? void 0 : _auth_currentUser.getIdToken());\n            if (!token) {\n                throw new Error('Not authenticated');\n            }\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/categories\"), {\n                method: 'POST',\n                headers: {\n                    'Authorization': \"Bearer \".concat(token),\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(category)\n            });\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('Server response:', {\n                    status: response.status,\n                    statusText: response.statusText,\n                    body: errorText\n                });\n                throw new Error(errorText || 'Failed to create category');\n            }\n            return response.json();\n        } catch (error) {\n            console.error('Error creating category:', error);\n            throw error;\n        }\n    },\n    updateCategory: async (id, category)=>{\n        try {\n            var _auth_currentUser;\n            const token = await ((_auth_currentUser = _lib_firebase__WEBPACK_IMPORTED_MODULE_0__.auth.currentUser) === null || _auth_currentUser === void 0 ? void 0 : _auth_currentUser.getIdToken());\n            if (!token) {\n                throw new Error('Not authenticated');\n            }\n            console.log('Updating category with ID:', id);\n            console.log('Category data:', category);\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/categories/\").concat(encodeURIComponent(id)), {\n                method: 'PUT',\n                headers: {\n                    'Authorization': \"Bearer \".concat(token),\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(category)\n            });\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error('Server error response:', errorText);\n                try {\n                    const errorData = JSON.parse(errorText);\n                    throw new Error(errorData.error || 'Failed to update category');\n                } catch (e) {\n                    throw new Error(errorText || 'Failed to update category');\n                }\n            }\n            const result = await response.json();\n            console.log('Update successful:', result);\n            return result;\n        } catch (error) {\n            console.error('Error updating category:', error);\n            throw error;\n        }\n    },\n    deleteCategory: async (id)=>{\n        try {\n            if (!_lib_firebase__WEBPACK_IMPORTED_MODULE_0__.auth.currentUser) {\n                throw new Error('Not authenticated');\n            }\n            const token = await _lib_firebase__WEBPACK_IMPORTED_MODULE_0__.auth.currentUser.getIdToken();\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/categories/\").concat(encodeURIComponent(id)), {\n                method: 'DELETE',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': \"Bearer \".concat(token)\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>null);\n                throw new Error((errorData === null || errorData === void 0 ? void 0 : errorData.error) || 'Failed to delete category');\n            }\n        } catch (error) {\n            console.error('Error deleting category:', error);\n            throw error;\n        }\n    }\n};\n// Brand API endpoints\nconst brandAPI = {\n    getAllBrands: async ()=>{\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/brands\"), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Cache-Control': 'no-cache',\n                    'cache-control': 'no-cache'\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>null);\n                const errorMessage = (errorData === null || errorData === void 0 ? void 0 : errorData.error) || 'Failed to fetch brands';\n                console.error('Server error:', errorMessage);\n                return [];\n            }\n            return response.json();\n        } catch (error) {\n            console.error('Error fetching brands:', error);\n            return [];\n        }\n    },\n    getBrandBySlug: async (slug)=>{\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/brands/slug/\").concat(encodeURIComponent(slug)), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Cache-Control': 'no-cache',\n                    'cache-control': 'no-cache'\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>null);\n                if (response.status === 404) return null;\n                const errorMessage = (errorData === null || errorData === void 0 ? void 0 : errorData.error) || 'Failed to fetch brand';\n                console.error('Server error:', errorMessage);\n                return null;\n            }\n            return response.json();\n        } catch (error) {\n            console.error('Error fetching brand:', error);\n            return null;\n        }\n    },\n    getFeaturedBrands: async ()=>{\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/brands/featured\"), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Cache-Control': 'no-cache',\n                    'cache-control': 'no-cache'\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>null);\n                const errorMessage = (errorData === null || errorData === void 0 ? void 0 : errorData.error) || 'Failed to fetch featured brands';\n                console.error('Server error:', errorMessage);\n                return [];\n            }\n            return response.json();\n        } catch (error) {\n            console.error('Error fetching featured brands:', error);\n            return [];\n        }\n    },\n    createBrand: async (brand)=>{\n        try {\n            if (!_lib_firebase__WEBPACK_IMPORTED_MODULE_0__.auth.currentUser) {\n                throw new Error('Not authenticated');\n            }\n            const token = await _lib_firebase__WEBPACK_IMPORTED_MODULE_0__.auth.currentUser.getIdToken();\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/brands\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': \"Bearer \".concat(token)\n                },\n                body: JSON.stringify(brand)\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>null);\n                throw new Error((errorData === null || errorData === void 0 ? void 0 : errorData.error) || 'Failed to create brand');\n            }\n            return response.json();\n        } catch (error) {\n            console.error('Error creating brand:', error);\n            throw error;\n        }\n    },\n    updateBrand: async (id, brand)=>{\n        try {\n            if (!_lib_firebase__WEBPACK_IMPORTED_MODULE_0__.auth.currentUser) {\n                throw new Error('Not authenticated');\n            }\n            const token = await _lib_firebase__WEBPACK_IMPORTED_MODULE_0__.auth.currentUser.getIdToken();\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/brands/\").concat(id), {\n                method: 'PUT',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': \"Bearer \".concat(token)\n                },\n                body: JSON.stringify(brand)\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>null);\n                throw new Error((errorData === null || errorData === void 0 ? void 0 : errorData.error) || 'Failed to update brand');\n            }\n            return response.json();\n        } catch (error) {\n            console.error('Error updating brand:', error);\n            throw error;\n        }\n    },\n    deleteBrand: async (id)=>{\n        try {\n            if (!_lib_firebase__WEBPACK_IMPORTED_MODULE_0__.auth.currentUser) {\n                throw new Error('Not authenticated');\n            }\n            const token = await _lib_firebase__WEBPACK_IMPORTED_MODULE_0__.auth.currentUser.getIdToken();\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/brands/\").concat(id), {\n                method: 'DELETE',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': \"Bearer \".concat(token)\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>null);\n                throw new Error((errorData === null || errorData === void 0 ? void 0 : errorData.error) || 'Failed to delete brand');\n            }\n        } catch (error) {\n            console.error('Error deleting brand:', error);\n            throw error;\n        }\n    }\n};\n// Search API endpoint\nconst searchAPI = {\n    search: async (query)=>{\n        try {\n            const response = await fetch(\"\".concat(API_BASE_URL, \"/api/search?q=\").concat(encodeURIComponent(query)), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Cache-Control': 'no-cache'\n                }\n            });\n            if (!response.ok) {\n                throw new Error('Search request failed');\n            }\n            const results = await response.json();\n            return results;\n        } catch (error) {\n            console.error('Error searching cars:', error);\n            return [];\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9hcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBR3NDO0FBRXRDLG1FQUFtRTtBQUNuRSxNQUFNQyxlQUFlQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLHVCQUF1QixJQUFJO0FBQzVEQyxRQUFRQyxHQUFHLENBQUMsaUJBQWlCTDtBQUM3QkksUUFBUUMsR0FBRyxDQUFDLDRCQUE0QkosT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyx1QkFBdUI7QUFFM0Usb0JBQW9CO0FBQ2IsTUFBTUcsU0FBUztJQUNwQkMsWUFBWTtRQUNWLElBQUk7WUFDRixNQUFNQyxXQUFXLE1BQU1DLE1BQU0sR0FBZ0IsT0FBYlQsY0FBYSxjQUFZO2dCQUN2RFUsUUFBUTtnQkFDUkMsU0FBUztvQkFDUCxnQkFBZ0I7b0JBQ2hCLGlCQUFpQjtvQkFDakIsaUJBQWlCO2dCQUNuQjtZQUNGO1lBQ0EsSUFBSSxDQUFDSCxTQUFTSSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFFBQVEsTUFBTUwsU0FBU00sSUFBSTtnQkFDakMsTUFBTSxJQUFJQyxNQUFNRixTQUFTO1lBQzNCO1lBQ0EsT0FBT0wsU0FBU1EsSUFBSTtRQUN0QixFQUFFLE9BQU9ILE9BQU87WUFDZFQsUUFBUVMsS0FBSyxDQUFDLHdCQUF3QkE7WUFDdEMsT0FBTyxFQUFFLEVBQUUseUNBQXlDO1FBQ3REO0lBQ0Y7SUFFQUksZUFBZSxPQUFPQztRQUNwQixJQUFJO1lBQ0YsTUFBTVYsV0FBVyxNQUFNQyxNQUFNLEdBQWlDVSxPQUE5Qm5CLGNBQWEsbUJBQTBDLE9BQXpCbUIsbUJBQW1CRCxRQUFTO2dCQUN4RlIsUUFBUTtnQkFDUkMsU0FBUztvQkFDUCxnQkFBZ0I7b0JBQ2hCLGlCQUFpQjtvQkFDakIsaUJBQWlCO2dCQUNuQjtZQUNGO1lBQ0EsSUFBSSxDQUFDSCxTQUFTSSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFFBQVEsTUFBTUwsU0FBU00sSUFBSTtnQkFDakMsTUFB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O0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL3N1cmEvRG93bmxvYWRzL2F1dG9sdXhlLW1haW4gMi9zcmMvc2VydmljZXMvYXBpLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENhciB9IGZyb20gJ0AvdHlwZXMvY2FyJztcbmltcG9ydCB7IENhdGVnb3J5IH0gZnJvbSAnQC90eXBlcy9jYXRlZ29yeSc7XG5pbXBvcnQgeyBCcmFuZCB9IGZyb20gJ0AvdHlwZXMvYnJhbmQnO1xuaW1wb3J0IHsgYXV0aCB9IGZyb20gJ0AvbGliL2ZpcmViYXNlJztcblxuLy8gVXNlIGV4dGVybmFsIGJhY2tlbmQgc2VydmVyIChSZW5kZXIpIGluc3RlYWQgb2YgbG9jYWwgQVBJIHJvdXRlc1xuY29uc3QgQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkFDS0VORF9VUkwgfHwgJyc7XG5jb25zb2xlLmxvZygnQVBJX0JBU0VfVVJMOicsIEFQSV9CQVNFX1VSTCk7XG5jb25zb2xlLmxvZygnTkVYVF9QVUJMSUNfQkFDS0VORF9VUkw6JywgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkFDS0VORF9VUkwpO1xuXG4vLyBDYXIgQVBJIGVuZHBvaW50c1xuZXhwb3J0IGNvbnN0IGNhckFQSSA9IHtcbiAgZ2V0QWxsQ2FyczogYXN5bmMgKCk6IFByb21pc2U8Q2FyW10+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9jYXJzYCwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZScsXG4gICAgICAgICAgJ2NhY2hlLWNvbnRyb2wnOiAnbm8tY2FjaGUnXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yIHx8ICdGYWlsZWQgdG8gZmV0Y2ggY2FycycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY2FyczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107IC8vIFJldHVybiBlbXB0eSBhcnJheSBpbnN0ZWFkIG9mIHRocm93aW5nXG4gICAgfVxuICB9LFxuXG4gIGdldENhcnNCeVR5cGU6IGFzeW5jICh0eXBlOiBzdHJpbmcpOiBQcm9taXNlPENhcltdPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvY2Fycy90eXBlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHR5cGUpfWAsIHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbm8tY2FjaGUnLFxuICAgICAgICAgICdjYWNoZS1jb250cm9sJzogJ25vLWNhY2hlJ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvciB8fCAnRmFpbGVkIHRvIGZldGNoIGNhcnMgYnkgdHlwZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY2FycyBieSB0eXBlOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTsgLy8gUmV0dXJuIGVtcHR5IGFycmF5IGluc3RlYWQgb2YgdGhyb3dpbmdcbiAgICB9XG4gIH0sXG5cbiAgZ2V0Q2Fyc0J5VGFnOiBhc3luYyAodGFnOiBzdHJpbmcpOiBQcm9taXNlPENhcltdPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvY2Fycy90YWcvJHtlbmNvZGVVUklDb21wb25lbnQodGFnKX1gLCB7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJyxcbiAgICAgICAgICAnY2FjaGUtY29udHJvbCc6ICduby1jYWNoZSdcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IgfHwgJ0ZhaWxlZCB0byBmZXRjaCBjYXJzIGJ5IHRhZycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY2FycyBieSB0YWc6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdOyAvLyBSZXR1cm4gZW1wdHkgYXJyYXkgaW5zdGVhZCBvZiB0aHJvd2luZ1xuICAgIH1cbiAgfSxcblxuICBnZXRDYXJzQnlGdWVsVHlwZTogYXN5bmMgKGZ1ZWxUeXBlOiBzdHJpbmcpOiBQcm9taXNlPENhcltdPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvY2Fycy9mdWVsLXR5cGUvJHtlbmNvZGVVUklDb21wb25lbnQoZnVlbFR5cGUpfWAsIHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbm8tY2FjaGUnLFxuICAgICAgICAgICdjYWNoZS1jb250cm9sJzogJ25vLWNhY2hlJ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvciB8fCAnRmFpbGVkIHRvIGZldGNoIGNhcnMgYnkgZnVlbCB0eXBlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjYXJzIGJ5IGZ1ZWwgdHlwZTonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107IC8vIFJldHVybiBlbXB0eSBhcnJheSBpbnN0ZWFkIG9mIHRocm93aW5nXG4gICAgfVxuICB9LFxuXG4gIGdldENhcnNCeUJyYW5kOiBhc3luYyAoYnJhbmQ6IHN0cmluZyk6IFByb21pc2U8Q2FyW10+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9jYXJzL2JyYW5kLyR7ZW5jb2RlVVJJQ29tcG9uZW50KGJyYW5kKX1gLCB7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJyxcbiAgICAgICAgICAnY2FjaGUtY29udHJvbCc6ICduby1jYWNoZSdcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IgfHwgJ0ZhaWxlZCB0byBmZXRjaCBjYXJzIGJ5IGJyYW5kJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjYXJzIGJ5IGJyYW5kOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTsgLy8gUmV0dXJuIGVtcHR5IGFycmF5IGluc3RlYWQgb2YgdGhyb3dpbmdcbiAgICB9XG4gIH0sXG5cbiAgZ2V0RmVhdHVyZWRDYXJzOiBhc3luYyAoKTogUHJvbWlzZTxDYXJbXT4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL2NhcnMvZmVhdHVyZWRgLCB7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJyxcbiAgICAgICAgICAnY2FjaGUtY29udHJvbCc6ICduby1jYWNoZSdcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IgfHwgJ0ZhaWxlZCB0byBmZXRjaCBmZWF0dXJlZCBjYXJzJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBmZWF0dXJlZCBjYXJzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTsgLy8gUmV0dXJuIGVtcHR5IGFycmF5IGluc3RlYWQgb2YgdGhyb3dpbmdcbiAgICB9XG4gIH0sXG5cbiAgZ2V0Q2FyQnlJZDogYXN5bmMgKGlkOiBzdHJpbmcpOiBQcm9taXNlPENhcj4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL2NhcnMvJHtlbmNvZGVVUklDb21wb25lbnQoaWQpfWAsIHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbm8tY2FjaGUnLFxuICAgICAgICAgICdjYWNoZS1jb250cm9sJzogJ25vLWNhY2hlJ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvciB8fCAnRmFpbGVkIHRvIGZldGNoIGNhcicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY2FyOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yOyAvLyBSZS10aHJvdyB0aGUgZXJyb3JcbiAgICB9XG4gIH0sXG5cbiAgY3JlYXRlQ2FyOiBhc3luYyAoY2FyOiBQYXJ0aWFsPENhcj4pOiBQcm9taXNlPENhcj4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWF1dGguY3VycmVudFVzZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aGVudGljYXRlZCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCBhdXRoLmN1cnJlbnRVc2VyLmdldElkVG9rZW4oKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9jYXJzYCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShjYXIpLFxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IgfHwgJ0ZhaWxlZCB0byBjcmVhdGUgY2FyJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBjYXI6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9LFxuXG4gIHVwZGF0ZUNhcjogYXN5bmMgKGlkOiBzdHJpbmcsIGNhcjogUGFydGlhbDxDYXI+KTogUHJvbWlzZTxDYXI+ID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFhdXRoLmN1cnJlbnRVc2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGF1dGhlbnRpY2F0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgYXV0aC5jdXJyZW50VXNlci5nZXRJZFRva2VuKCk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvY2Fycy8ke2VuY29kZVVSSUNvbXBvbmVudChpZCl9YCwge1xuICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGNhciksXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvciB8fCAnRmFpbGVkIHRvIHVwZGF0ZSBjYXInKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVwZGF0ZWRDYXIgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICByZXR1cm4gdXBkYXRlZENhcjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgY2FyOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSxcblxuICBkZWxldGVDYXI6IGFzeW5jIChpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghYXV0aC5jdXJyZW50VXNlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdXRoZW50aWNhdGVkJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IGF1dGguY3VycmVudFVzZXIuZ2V0SWRUb2tlbigpO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL2NhcnMvJHtlbmNvZGVVUklDb21wb25lbnQoaWQpfWAsIHtcbiAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+IG51bGwpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhPy5lcnJvciB8fCAnRmFpbGVkIHRvIGRlbGV0ZSBjYXInKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgY2FyOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSxcbn07XG5cbi8vIENhdGVnb3J5IEFQSSBlbmRwb2ludHNcbmV4cG9ydCBjb25zdCBjYXRlZ29yeUFQSSA9IHtcbiAgZ2V0Q2F0ZWdvcmllc0J5VHlwZTogYXN5bmMgKHR5cGU6ICdjYXJUeXBlJyB8ICdmdWVsVHlwZScgfCAndGFnJyk6IFByb21pc2U8Q2F0ZWdvcnlbXT4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IGF1dGguY3VycmVudFVzZXI/LmdldElkVG9rZW4oKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvY2F0ZWdvcmllcy90eXBlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHR5cGUpfWAsIHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiB0b2tlbiA/IGBCZWFyZXIgJHt0b2tlbn1gIDogJycsXG4gICAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbm8tY2FjaGUnLFxuICAgICAgICAgICdjYWNoZS1jb250cm9sJzogJ25vLWNhY2hlJ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvciB8fCAnRmFpbGVkIHRvIGZldGNoIGNhdGVnb3JpZXMgYnkgdHlwZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY2F0ZWdvcmllcyBieSB0eXBlOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0Q2F0ZWdvcnlCeVNsdWc6IGFzeW5jIChzbHVnOiBzdHJpbmcpOiBQcm9taXNlPENhdGVnb3J5IHwgbnVsbD4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL2NhdGVnb3JpZXMvc2x1Zy8ke2VuY29kZVVSSUNvbXBvbmVudChzbHVnKX1gLCB7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJyxcbiAgICAgICAgICAnY2FjaGUtY29udHJvbCc6ICduby1jYWNoZSdcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IgfHwgJ0ZhaWxlZCB0byBmZXRjaCBjYXRlZ29yeSBieSBzbHVnJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjYXRlZ29yeSBieSBzbHVnOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcblxuICBnZXRGZWF0dXJlZENhdGVnb3JpZXM6IGFzeW5jICgpOiBQcm9taXNlPENhdGVnb3J5W10+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCBhdXRoLmN1cnJlbnRVc2VyPy5nZXRJZFRva2VuKCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL2NhdGVnb3JpZXMvZmVhdHVyZWRgLCB7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogdG9rZW4gPyBgQmVhcmVyICR7dG9rZW59YCA6ICcnLFxuICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJyxcbiAgICAgICAgICAnY2FjaGUtY29udHJvbCc6ICduby1jYWNoZSdcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IgfHwgJ0ZhaWxlZCB0byBmZXRjaCBmZWF0dXJlZCBjYXRlZ29yaWVzJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBmZWF0dXJlZCBjYXRlZ29yaWVzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0sXG5cbiAgY3JlYXRlQ2F0ZWdvcnk6IGFzeW5jIChjYXRlZ29yeTogUGFydGlhbDxDYXRlZ29yeT4pOiBQcm9taXNlPENhdGVnb3J5PiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgYXV0aC5jdXJyZW50VXNlcj8uZ2V0SWRUb2tlbigpO1xuICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdXRoZW50aWNhdGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvY2F0ZWdvcmllc2AsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoY2F0ZWdvcnkpLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTZXJ2ZXIgcmVzcG9uc2U6Jywge1xuICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgYm9keTogZXJyb3JUZXh0XG4gICAgICAgIH0pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JUZXh0IHx8ICdGYWlsZWQgdG8gY3JlYXRlIGNhdGVnb3J5Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBjYXRlZ29yeTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlQ2F0ZWdvcnk6IGFzeW5jIChpZDogc3RyaW5nLCBjYXRlZ29yeTogUGFydGlhbDxDYXRlZ29yeT4pOiBQcm9taXNlPENhdGVnb3J5PiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgYXV0aC5jdXJyZW50VXNlcj8uZ2V0SWRUb2tlbigpO1xuICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdXRoZW50aWNhdGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdVcGRhdGluZyBjYXRlZ29yeSB3aXRoIElEOicsIGlkKTtcbiAgICAgIGNvbnNvbGUubG9nKCdDYXRlZ29yeSBkYXRhOicsIGNhdGVnb3J5KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9jYXRlZ29yaWVzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KGlkKX1gLCB7XG4gICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoY2F0ZWdvcnkpLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTZXJ2ZXIgZXJyb3IgcmVzcG9uc2U6JywgZXJyb3JUZXh0KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBKU09OLnBhcnNlKGVycm9yVGV4dCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5lcnJvciB8fCAnRmFpbGVkIHRvIHVwZGF0ZSBjYXRlZ29yeScpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yVGV4dCB8fCAnRmFpbGVkIHRvIHVwZGF0ZSBjYXRlZ29yeScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUubG9nKCdVcGRhdGUgc3VjY2Vzc2Z1bDonLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgY2F0ZWdvcnk6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9LFxuXG4gIGRlbGV0ZUNhdGVnb3J5OiBhc3luYyAoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWF1dGguY3VycmVudFVzZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aGVudGljYXRlZCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCBhdXRoLmN1cnJlbnRVc2VyLmdldElkVG9rZW4oKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9jYXRlZ29yaWVzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KGlkKX1gLCB7XG4gICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3Rva2VufWBcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YT8uZXJyb3IgfHwgJ0ZhaWxlZCB0byBkZWxldGUgY2F0ZWdvcnknKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgY2F0ZWdvcnk6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9LFxufTtcblxuLy8gQnJhbmQgQVBJIGVuZHBvaW50c1xuZXhwb3J0IGNvbnN0IGJyYW5kQVBJID0ge1xuICBnZXRBbGxCcmFuZHM6IGFzeW5jICgpOiBQcm9taXNlPEJyYW5kW10+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9icmFuZHNgLCB7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJyxcbiAgICAgICAgICAnY2FjaGUtY29udHJvbCc6ICduby1jYWNoZSdcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3JEYXRhPy5lcnJvciB8fCAnRmFpbGVkIHRvIGZldGNoIGJyYW5kcyc7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NlcnZlciBlcnJvcjonLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBicmFuZHM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfSxcblxuICBnZXRCcmFuZEJ5U2x1ZzogYXN5bmMgKHNsdWc6IHN0cmluZyk6IFByb21pc2U8QnJhbmQgfCBudWxsPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvYnJhbmRzL3NsdWcvJHtlbmNvZGVVUklDb21wb25lbnQoc2x1Zyl9YCwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZScsXG4gICAgICAgICAgJ2NhY2hlLWNvbnRyb2wnOiAnbm8tY2FjaGUnXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yRGF0YT8uZXJyb3IgfHwgJ0ZhaWxlZCB0byBmZXRjaCBicmFuZCc7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1NlcnZlciBlcnJvcjonLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGJyYW5kOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcblxuICBnZXRGZWF0dXJlZEJyYW5kczogYXN5bmMgKCk6IFByb21pc2U8QnJhbmRbXT4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL2JyYW5kcy9mZWF0dXJlZGAsIHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbm8tY2FjaGUnLFxuICAgICAgICAgICdjYWNoZS1jb250cm9sJzogJ25vLWNhY2hlJ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+IG51bGwpO1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvckRhdGE/LmVycm9yIHx8ICdGYWlsZWQgdG8gZmV0Y2ggZmVhdHVyZWQgYnJhbmRzJztcbiAgICAgICAgY29uc29sZS5lcnJvcignU2VydmVyIGVycm9yOicsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGZlYXR1cmVkIGJyYW5kczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZUJyYW5kOiBhc3luYyAoYnJhbmQ6IFBhcnRpYWw8QnJhbmQ+KTogUHJvbWlzZTxCcmFuZD4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWF1dGguY3VycmVudFVzZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXV0aGVudGljYXRlZCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCBhdXRoLmN1cnJlbnRVc2VyLmdldElkVG9rZW4oKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9icmFuZHNgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJyYW5kKVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YT8uZXJyb3IgfHwgJ0ZhaWxlZCB0byBjcmVhdGUgYnJhbmQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIGJyYW5kOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGVCcmFuZDogYXN5bmMgKGlkOiBzdHJpbmcsIGJyYW5kOiBQYXJ0aWFsPEJyYW5kPik6IFByb21pc2U8QnJhbmQ+ID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFhdXRoLmN1cnJlbnRVc2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGF1dGhlbnRpY2F0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgYXV0aC5jdXJyZW50VXNlci5nZXRJZFRva2VuKCk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvYnJhbmRzLyR7aWR9YCwge1xuICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJyYW5kKVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YT8uZXJyb3IgfHwgJ0ZhaWxlZCB0byB1cGRhdGUgYnJhbmQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGJyYW5kOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSxcblxuICBkZWxldGVCcmFuZDogYXN5bmMgKGlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFhdXRoLmN1cnJlbnRVc2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGF1dGhlbnRpY2F0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgYXV0aC5jdXJyZW50VXNlci5nZXRJZFRva2VuKCk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX0JBU0VfVVJMfS9hcGkvYnJhbmRzLyR7aWR9YCwge1xuICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0b2tlbn1gXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gbnVsbCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGE/LmVycm9yIHx8ICdGYWlsZWQgdG8gZGVsZXRlIGJyYW5kJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIGJyYW5kOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufTtcblxuLy8gU2VhcmNoIEFQSSBlbmRwb2ludFxuZXhwb3J0IGNvbnN0IHNlYXJjaEFQSSA9IHtcbiAgc2VhcmNoOiBhc3luYyAocXVlcnk6IHN0cmluZyk6IFByb21pc2U8Q2FyW10+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9zZWFyY2g/cT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9YCwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZSdcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWFyY2ggcmVxdWVzdCBmYWlsZWQnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZWFyY2hpbmcgY2FyczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbImF1dGgiLCJBUElfQkFTRV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQkFDS0VORF9VUkwiLCJjb25zb2xlIiwibG9nIiwiY2FyQVBJIiwiZ2V0QWxsQ2FycyIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwib2siLCJlcnJvciIsInRleHQiLCJFcnJvciIsImpzb24iLCJnZXRDYXJzQnlUeXBlIiwidHlwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsImdldENhcnNCeVRhZyIsInRhZyIsImdldENhcnNCeUZ1ZWxUeXBlIiwiZnVlbFR5cGUiLCJnZXRDYXJzQnlCcmFuZCIsImJyYW5kIiwiZ2V0RmVhdHVyZWRDYXJzIiwiZ2V0Q2FyQnlJZCIsImlkIiwiY3JlYXRlQ2FyIiwiY2FyIiwiY3VycmVudFVzZXIiLCJ0b2tlbiIsImdldElkVG9rZW4iLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInVwZGF0ZUNhciIsInVwZGF0ZWRDYXIiLCJkZWxldGVDYXIiLCJlcnJvckRhdGEiLCJjYXRjaCIsImNhdGVnb3J5QVBJIiwiZ2V0Q2F0ZWdvcmllc0J5VHlwZSIsImdldENhdGVnb3J5QnlTbHVnIiwic2x1ZyIsInN0YXR1cyIsImdldEZlYXR1cmVkQ2F0ZWdvcmllcyIsImNyZWF0ZUNhdGVnb3J5IiwiY2F0ZWdvcnkiLCJlcnJvclRleHQiLCJzdGF0dXNUZXh0IiwidXBkYXRlQ2F0ZWdvcnkiLCJwYXJzZSIsImUiLCJyZXN1bHQiLCJkZWxldGVDYXRlZ29yeSIsImJyYW5kQVBJIiwiZ2V0QWxsQnJhbmRzIiwiZXJyb3JNZXNzYWdlIiwiZ2V0QnJhbmRCeVNsdWciLCJnZXRGZWF0dXJlZEJyYW5kcyIsImNyZWF0ZUJyYW5kIiwidXBkYXRlQnJhbmQiLCJkZWxldGVCcmFuZCIsInNlYXJjaEFQSSIsInNlYXJjaCIsInF1ZXJ5IiwicmVzdWx0cyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/api.ts\n"));

/***/ })

});